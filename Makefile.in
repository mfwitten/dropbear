# This Makefile is for Dropbear SSH Server and Client
# @configure_input@

# invocation:
# make PROGRAMS="dropbear dbclient scp" MULTI=1
#
# to make a multiple-program binary "dropbearmulti".
# This example will include dropbear, scp, dropbearkey, dropbearconvert, and
# dbclient functionality, and includes the progress-bar functionality in scp.

# It can often be very useful to have a variable that expands to the
# empty string; while any undefined variable will do, it's probably
# safest just to define one in particular:
NOTHING:=

ifndef PROGRAMS
	PROGRAMS=dropbear dbclient dropbearkey dropbearconvert
endif

maxprograms := dropbear dbclient dropbearkey dropbearconvert scp dropbearmulti

STATIC_LTC=libtomcrypt/libtomcrypt.a
STATIC_LTM=libtommath/libtommath.a

LIBTOM_LIBS=@LIBTOM_LIBS@

ifeq (@BUNDLED_LIBTOM@, 1)
LIBTOM_LIBS=$(STATIC_LTC) $(STATIC_LTM)
LIBTOM_DEPS=$(LIBTOM_LIBS)
CPPFLAGS+=-I$(srcdir)/libtomcrypt/src/headers
endif

COMMONOBJS=dbutil.o buffer.o dbhelpers.o \
		dss.o bignum.o \
		signkey.o rsa.o dbrandom.o \
		queue.o \
		atomicio.o compat.o fake-rfc2553.o \
		ltc_prng.o ecc.o ecdsa.o crypto_desc.o \
		gensignkey.o gendss.o genrsa.o

SVROBJS=svr-kex.o svr-auth.o sshpty.o \
		svr-authpasswd.o svr-authpubkey.o svr-authpubkeyoptions.o svr-session.o svr-service.o \
		svr-chansession.o svr-runopts.o svr-agentfwd.o svr-main.o svr-x11fwd.o\
		svr-tcpfwd.o svr-authpam.o

CLIOBJS=cli-main.o cli-auth.o cli-authpasswd.o cli-kex.o \
		cli-session.o cli-runopts.o cli-chansession.o \
		cli-authpubkey.o cli-tcpfwd.o cli-channel.o cli-authinteract.o \
		cli-agentfwd.o 

CLISVROBJS=common-session.o packet.o common-algo.o common-kex.o \
			common-channel.o common-chansession.o termcodes.o loginrec.o \
			tcp-accept.o listener.o process-packet.o dh_groups.o \
			common-runopts.o circbuffer.o curve25519-donna.o list.o netio.o

dropbearobjs=$(COMMONOBJS) $(CLISVROBJS) $(SVROBJS)
dbclientobjs=$(COMMONOBJS) $(CLISVROBJS) $(CLIOBJS)
dropbearkeyobjs=$(COMMONOBJS) dropbearkey.o
dropbearconvertobjs=$(COMMONOBJS) dropbearconvert.o keyimport.o
scpobjs=scp.o progressmeter.o atomicio.o scpmisc.o compat.o
programobjs=$(sort $(foreach prog, $(PROGRAMS), $($(prog)objs)))
dropbearmultiobjs=dbmulti.o $(programobjs)

maxobjs=$(sort \
  $(dropbearobjs) \
  $(dbclientobjs) \
  $(dropbearkeyobjs) \
  $(dropbearconvertobjs) \
  $(scpobjs) \
  $(dropbearmultiobjs) \
)

VPATH=@srcdir@
srcdir=@srcdir@

prefix=@prefix@
exec_prefix=@exec_prefix@
datarootdir = @datarootdir@
bindir=@bindir@
sbindir=@sbindir@
mandir=@mandir@

.DELETE_ON_ERROR:

PATH_old:=$(PATH)
PATH:=@PATH@

notify=$(info $1)

ifneq ($(PATH),$(PATH_old))
  $(call notify,Switching PATH from:)
  $(call notify,$(NOTHING)  $(PATH_old))
  $(call notify,to:)
  $(call notify,$(NOTHING)  $(PATH))
endif

CPP=@CPP@
CC=@CC@
AR=@AR@
RANLIB=@RANLIB@
STRIP=@STRIP@
MKDIR_P=@MKDIR_P@
INSTALL=@INSTALL@
CPPFLAGS+=@CPPFLAGS@ -I. -I$(srcdir)
CFLAGS+=@CFLAGS@
LDFLAGS+=@LDFLAGS@
LIBS+=@LIBS@

EXEEXT=@EXEEXT@

STATIC=@STATIC@

dynamic_prereqs_M=@dynamic_prereqs_M@
dynamic_prereqs_MD=@dynamic_prereqs_MD@

# whether we're building client, server, or both for the common objects.
# evilness so we detect 'dropbear' by itself as a word
ifneq (,$(strip $(foreach prog, $(PROGRAMS), $(findstring ZdropbearZ, Z$(prog)Z))))
	CPPFLAGS+=-DDROPBEAR_SERVER
endif
ifneq (,$(strip $(foreach prog, $(PROGRAMS), $(findstring ZdbclientZ, Z$(prog)Z))))
	CPPFLAGS+=-DDROPBEAR_CLIENT
endif


# these are exported so that libtomcrypt's makefile will use them
export CPP CC
export CPPFLAGS CFLAGS LDFLAGS
export RANLIB AR STRIP

ifeq ($(STATIC), 1)
	LDFLAGS+=-static
endif

ifeq ($(MULTI), 1)
	allobjs=$(dropbearmultiobjs)
	CPPFLAGS+=$(addprefix -DDBMULTI_, $(PROGRAMS)) -DDROPBEAR_MULTI
	TARGETS_NAMES=dropbearmulti
else
	allobjs=$(programobjs)
	TARGETS_NAMES=$(PROGRAMS)
endif

TARGETS=$(addsuffix $(EXEEXT), $(TARGETS_NAMES))

# For backwards compatibility, `SCPPROGRESS' is still supported here.
ifeq ($(SCPPROGRESS), 1)
	CPPFLAGS+=-DPROGRESS_METER
endif

.PHONY: all
all: $(TARGETS)

.PHONY: strip
strip: $(TARGETS)
	$(STRIP) $^

TARGETS_inst_=$(addprefix inst_, $(TARGETS_NAMES))

.PHONY: install
install: $(TARGETS_inst_)

.PHONY: insmultidropbear
insmultidropbear: dropbearmulti$(EXEEXT)
	$(INSTALL) -d $(DESTDIR)$(sbindir)
	-rm -f $(DESTDIR)$(sbindir)/dropbear$(EXEEXT)
	-ln -s $(bindir)/dropbearmulti$(EXEEXT) $(DESTDIR)$(sbindir)/dropbear$(EXEEXT) 
	$(INSTALL) -d $(DESTDIR)$(mandir)/man8
	$(INSTALL) -m 644 $(srcdir)/dropbear.8  $(DESTDIR)$(mandir)/man8/dropbear.8

PROGRAMS_insmulti=$(addprefix insmulti, $(PROGRAMS))

.PHONY: $(PROGRAMS_insmulti)
$(filter-out insmultidropbear,$(PROGRAMS_insmulti)): insmulti%: dropbearmulti$(EXEEXT)
	$(INSTALL) -d $(DESTDIR)$(bindir)
	-rm -f $(DESTDIR)$(bindir)/$*$(EXEEXT) 
	-ln -s $(bindir)/dropbearmulti$(EXEEXT) $(DESTDIR)$(bindir)/$*$(EXEEXT) 
	$(INSTALL) -d $(DESTDIR)$(mandir)/man1
	if test -e $(srcdir)/$*.1; then \
	  $(INSTALL) -m 644 $(srcdir)/$*.1 $(DESTDIR)$(mandir)/man1/$*.1; \
	fi

# dropbear should go in sbin, so it needs a separate rule
.PHONY: inst_dropbear
inst_dropbear: dropbear$(EXEEXT)
	$(INSTALL) -d $(DESTDIR)$(sbindir)
	$(INSTALL) dropbear$(EXEEXT) $(DESTDIR)$(sbindir)
	$(INSTALL) -d $(DESTDIR)$(mandir)/man8
	$(INSTALL) -m 644 $(srcdir)/dropbear.8 $(DESTDIR)$(mandir)/man8/dropbear.8

.PHONY: $(TARGETS_inst_)
$(filter-out inst_dropbear,$(TARGETS_inst_)): inst_%: %$(EXEEXT)
	$(INSTALL) -d $(DESTDIR)$(bindir)
	$(INSTALL) $*$(EXEEXT) $(DESTDIR)$(bindir)
	$(INSTALL) -d $(DESTDIR)$(mandir)/man1
	if test -e $(srcdir)/$*.1; then \
	  $(INSTALL) -m 644 $(srcdir)/$*.1 $(DESTDIR)$(mandir)/man1/$*.1; \
	fi

.PHONY: inst_dropbearmulti
inst_dropbearmulti: $(PROGRAMS_insmulti)

# This defines $(options_headers) and $(default_options_h) and $(default_options_h_in)
options_headers_dir:=
include $(srcdir)/build-system/options/headers.mk

define targets_without_dynamic_prereqs :=
  $(STATIC_LTC)
  $(STATIC_LTM)
  libtomcrypt
  libtommath
  ltc-clean
  ltm-clean
  clean
  thisclean
  distclean
  tidy
  $(default_options_h)
endef

prereqs_dir:=build-system/prereqs
include $(srcdir)/$(prereqs_dir)/include.mk

$(default_options_h): $(default_options_h_in)
	@echo Making $@; \
	$(srcdir)/build-system/options/ifndef_wrapper.sh $(srcdir) <$< >$@

$(localoptions_h):
	@echo Making $@; \
	touch $(localoptions_h)

$(allobjs): $(options_headers)

dropbear$(EXEEXT): $(dropbearobjs) $(LIBTOM_DEPS)
	$(CC) $(LDFLAGS) -o $@ $(dropbearobjs) $(LIBTOM_LIBS) $(LIBS) @CRYPTLIB@

dbclient$(EXEEXT): $(dbclientobjs) $(LIBTOM_DEPS)
	$(CC) $(LDFLAGS) -o $@ $(dbclientobjs) $(LIBTOM_LIBS) $(LIBS)

dropbearkey$(EXEEXT): $(dropbearkeyobjs) $(LIBTOM_DEPS)
	$(CC) $(LDFLAGS) -o $@ $(dropbearkeyobjs) $(LIBTOM_LIBS) $(LIBS)

dropbearconvert$(EXEEXT): $(dropbearconvertobjs) $(LIBTOM_DEPS)
	$(CC) $(LDFLAGS) -o $@ $(dropbearconvertobjs) $(LIBTOM_LIBS)

scp$(EXEEXT): $(scpobjs)
	$(CC) $(LDFLAGS) -o $@ $(scpobjs)

dropbearmulti$(EXEEXT): $(dropbearmultiobjs) $(LIBTOM_DEPS)
	$(CC) $(LDFLAGS) -o $@ $(dropbearmultiobjs) $(LIBTOM_LIBS) $(LIBS) @CRYPTLIB@

# Experimentation has revealed that `make' won't consider whether
# a target has been updated unless a recipe for that target has
# been run; thus, the following variable is used to help human
# readers understand that there is a recipe which does NOTHING.

$(STATIC_LTC): libtomcrypt
	$(NOTHING)

$(STATIC_LTM): libtommath
	$(NOTHING)

.PHONY: libtomcrypt
libtomcrypt: $(options_headers)
	$(MAKE) -C libtomcrypt

.PHONY: libtommath
libtommath:
	$(MAKE) -C libtommath

.PHONY: sizes
sizes: dropbear
	objdump -t dropbear|grep ".text"|cut -d "." -f 2|sort -rn

.PHONY: ltc-clean
ltc-clean:
	$(MAKE) -C libtomcrypt clean

.PHONY: ltm-clean
ltm-clean:
	$(MAKE) -C libtommath clean

.PHONY: clean
clean: ltc-clean ltm-clean thisclean

.PHONY: thisclean
thisclean:
	-rm -f dropbear$(EXEEXT) dbclient$(EXEEXT) dropbearkey$(EXEEXT) \
			dropbearconvert$(EXEEXT) scp$(EXEEXT) scp-progress$(EXEEXT) \
			dropbearmulti$(EXEEXT) *.o *.da *.bb *.bbg *.prof
	$(remove_dynamic_prereqs)
	-rm -f default_options.h

.PHONY: distclean
distclean: clean tidy
	-rm -f config-raw.h
	-rm -f Makefile

.PHONY: tidy
tidy:
	-rm -f *~ *.gcov */*~
